---
layout: post
title: "Leetcode:541. 反转字符串 II"
subtitle: ""
date: 2025-09-09
author: "Can"
header-img: "img/nature-1.jpg"
tags: ["Leetcode", "String", "Python", "Easy", "Two-Pointers Algorithm"]
---

Leetcode题目链接：[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

## Problem Description
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
* 如果剩余字符少于 k 个，则将剩余字符全部反转。
* 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

## Case
```
示例一
输入：s = "abcdefg", k = 2
输出："bacdfeg"

示例二
输入：s = "abcd", k = 2
输出："bacd"

提示
1 <= s.length <= 10的4次
s 仅由小写英文组成
1 <= k <= 10的4次
```

## Solution
**for循环以2k步长调用反转函数进行处理**
* 定义for循环进行处理
    * 若 i + k 小于当前字符串的大小，则字符串中当前2k个位置中存在前k个字符元素，对前k个元素调用reverse()进行反转
    * 若已到达数组末尾，最后一段字符串不满足k个，则执行reverse()函数，参数为 i 到 len（i 在循环结束时已指向最后一段不满足条件的字符串的首位）
* 这里自己定义的reverse()函数是左闭右闭的，所以在调用函数的时候右区间需要减一
* 返回字符串s

## Code
```python
class Solution {
public:
    void reverse(string& str, int begin, int end) {
        for(int i = begin, j = end; i < j; i++,j--) {
            swap(str[i], str[j]);
        }
    }
    string reverseStr(string s, int k) {
        int len = s.size();
        for(int i = 0; i < len; i += (2*k)) {
            if(i + k <= len) {
                reverse(s,i,i + k - 1);
                continue;
            }
            reverse(s,i,len - 1);
        }
        return s;
    }
};
```

## Result
![result](/img/leetcode/541.png)

## Trick
```python
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(s.begin() + i, s.begin() + min(i + k, n));
        }
        return s;
    }
};
```
