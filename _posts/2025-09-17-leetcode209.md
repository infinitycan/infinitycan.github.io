---
layout: post
title: "Leetcode:209.长度最小的子数组"
subtitle: ""
date: 2025-09-17
author: "Can"
header-img: "img/sunflower.jpg"
mathjax: true
tags: ["Leetcode", "Two-Points Algorithm", "Medium", "C++"]
---

## Problem Description
给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** $[nums_l, nums_{l+1}, ..., nums_{r-1}, nums_r]$，并返回其长度。如果不存在符合条件的子数组，返回`0`。

## Case
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：
输入：target = 4, nums = [1,4,4]
输出：1

示例3:
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0

## Solution
**双指针（滑动窗口）**
1. 定义start作为区间起始位置，end作为区间终点位置，result为最终区间长度，初始化为INT_MAX
2. 循环累加数组元素，找到满足累加器sum >= target的情况，此时start记录区间起始位置，end记录区间结束位置
3. 为了找到长度最小的连续子数组，需要对当前找到的这个**满足条件的区间进行进一步的缩小**（但是还是要满足缩小后的区间大小大于等于target值）
4. 采用将区间开始位置**start向后移动的方法进行区间缩减**，直至找到满足条件的最小区间，记录其长度为result
5. 继续执行for循环，执行所有可能情况以确定最终的result值
6. 最后需要进行特殊判断，若result的初始值（即INT的最大值）未被修改，意味着不存在符合条件的子数组，需要返回0（这里使用三元运算符进行判断）

## Code
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int start = 0,sum = 0,len = 0;
        int result = std::numeric_limits<int>::max();
        for(int end = 0; end < nums.size(); end++ ){
            sum += nums[end];
            while(sum >= target){
                len = end - start + 1;
                result = min(result, len);
                sum -= nums[start];
                start++;
            }
        }
        return result == std::numeric_limits<int>::max() ? 0 : result;
    }
};
```

## Result
![result](/img/leetcode/209.png)
