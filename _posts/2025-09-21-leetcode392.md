---
layout: post
title: "Leetcode:392.判断子序列"
subtitle: ""
date: 2025-09-21
author: "Can"
header-img: "img/roses.jpg"
tags: ["Leetcode", "Two-Pointers Algorithm", "Easy", "C++"]
---

Leetcode题目链接：[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/description/)

## Problem Description
给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

## Case
```
示例 1：
输入：s = "abc", t = "ahbgdc"
输出：true

示例 2：
输入：s = "axc", t = "ahbgdc"
输出：false
```

## Solution
**双指针遍历字符串比较**
* 使用指针 i 遍历字符串 s，指针 j 便利字符串 t，cnt统计匹配成功的次数
* 每匹配到一对字符则 s 串指针 i 后移，匹配下一个字符
* 不管匹配成功与否每次比较都让 t 串的指针 j 后移一位（条件始终成立）
* 最后判断匹配成功的次数（cnt）与 s 串的长度是否相等即可得出结果

## Code
```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m = s.size(),n = t.size();
        int i = 0,j = 0;
        int cnt = 0;
        while(i < m && j < n){
            if(s[i] == t[j]){
                i++;
                cnt++;
            }
            j++;
        }
        return cnt == m;
    }
};
```

## Result
![392.png](/img/leetcode/392.png)

## Official Code
```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.length(), m = t.length();
        int i = 0, j = 0;
        while (i < n && j < m) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        return i == n;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/is-subsequence/solutions/346539/pan-duan-zi-xu-lie-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## Conclusion
显然我的思路与官方的解题思路是一致的，通过官方解法可知我的方法的cnt变量是多余的，**使用 i 变量与字符串长度进行比较即可**，若 i 与 n 不相等则未完全匹配。