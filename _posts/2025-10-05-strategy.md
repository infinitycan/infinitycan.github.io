---
layout: post
title: "Strategy策略模式"
subtitle: ""
date: 2025-10-05
author: "Can"
header-img: "img/flower-1.jpg"
tags: ["Design-Pattern"]
---

## 定义

定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。

## 结构

![策略模式](/img/in-post/strategy.png)

## 例子

1. **抽象策略（Strategy Interface）**：定义所有算法（策略）必须遵循的接口。

   ```cpp
   // 抽象策略：所有排序算法的接口
   class SortStrategy {
   public:
       // 纯虚函数，定义了策略的契约
       virtual void sort(std::vector<int>& data) = 0;
   
       // 虚析构函数是C++良好实践
       virtual ~SortStrategy() = default; 
   };
   ```

2. **具体策略（Concrete Strategies）**:实现了抽象策略接口的具体算法。

   ```cpp
   // 具体策略 A：冒泡排序
   class BubbleSortStrategy : public SortStrategy {
   public:
       void sort(std::vector<int>& data) override {
           // ... 冒泡排序的具体实现代码 ...
           std::cout << "正在使用冒泡排序算法进行排序。\n";
           // 伪代码：实际执行排序逻辑
       }
   };
   
   // 具体策略 B：快速排序
   class QuickSortStrategy : public SortStrategy {
   public:
       void sort(std::vector<int>& data) override {
           // ... 快速排序的具体实现代码 ...
           std::cout << "正在使用快速排序算法进行排序。\n";
           // 伪代码：实际执行排序逻辑
       }
   };
   ```

3. **上下文（Context）:**持有对抽象策略对象的引用，并委托它执行任务。这是客户端交互的接口。

   ```cpp
   // 上下文：数据管理器
   class DataContext {
   private:
       // 持有一个抽象策略接口的指针
       SortStrategy* strategy_;
       std::vector<int> data_;
   
   public:
       // 构造函数：初始化时设置默认策略
       DataContext(SortStrategy* strategy, const std::vector<int>& initialData) 
           : strategy_(strategy), data_(initialData) {}
   
       // 设置策略：允许运行时动态切换算法 (满足开闭原则)
       void setStrategy(SortStrategy* newStrategy) {
           // 实际应用中可能需要管理旧策略的内存
           strategy_ = newStrategy; 
       }
   
       // 执行策略：委托给当前的策略对象
       void sortData() {
           if (strategy_) {
               std::cout << "数据排序开始...\n";
               // 核心：调用策略接口的方法，运行时决定具体执行哪个类的代码
               strategy_->sort(data_); 
               std::cout << "排序完成。\n";
           }
       }
       
       // ... 析构函数和数据访问方法等 ...
   };
   ```

4. **客户端使用:**客户端代码与 **`DataContext`** 交互，而不是直接与具体的排序算法交互。

   ```cpp
   int main() {
       std::vector<int> initialData = {5, 1, 4, 2, 8};
   
       // 1. 初始化，使用快速排序策略
       QuickSortStrategy quickSort;
       DataContext context(&quickSort, initialData);
   
       context.sortData(); // 输出: 正在使用快速排序算法进行排序。
   
       std::cout << "------------------\n";
   
       // 2. 运行时切换策略：改为冒泡排序
       BubbleSortStrategy bubbleSort;
       context.setStrategy(&bubbleSort);
   
       context.sortData(); // 输出: 正在使用冒泡排序算法进行排序。
       
       return 0;
   }
   ```

## 要点总结

- Strategy模式满足了设计原则中的**开闭原则**，即软件实体（类、模块、函数等）应该是对扩展开放（Open for Extension），但对修改关闭（Closed for Modification）的。
- Strategy模式及其子类为组件提供了一系列可重用的算法，使得类型在**运行时**能够方便地根据需要在各个算法之间进行切换。
- 该模式提供了替代条件判断语句的方法，通过**消除条件判断语句来实现解耦合**。含有大量条件判断语句的代码通常都需要使用Strategy模式。
- 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而**节省对象开销**。
- Strategy模式能够减少无关代码（或是调用频率低的代码）的内存占用，使得核心代码能够更大程度的被加载到与CPU交互最快的cache中。从**指令缓存局部性**的角度来看，将算法逻辑从一个庞大的 `if/else` 块中分离出来，确实可以帮助避免缓存污染。对于大多数现代系统而言，指令局部性提高带来的收益通常**大于**虚函数调用引入的微小开销。但关键在于，**策略模式的首要目的是设计解耦，缓存优化只是它在底层结构上带来的一个有益的次要效果。**

## 补充知识

- 并非所有的 `if-else` 结构都应该替换为策略模式，这种“一刀切”的做法就属于过度使用设计模式的机械化思想和行为。在以下场景中，策略模式反而会成为**不必要的负担**：
  - **逻辑简单且稳定：** 当 `if-else` 结构仅用于处理简单的、**本地化**的逻辑判断（例如输入验证、简单的状态检查），并且这些逻辑在未来几乎不会改变时。
  - **分支数量少：** 只有 2 到 3 个分支，且每个分支的逻辑都很简单。此时引入接口、上下文和多个具体类的开销，会使代码结构**过度复杂化**。
  - **性能要求极致且无扩展需求：** 如果代码对性能的直接性要求极高，任何形式的**间接寻址**（虚函数调用）都是需要避免的。此时，直接的 `if-else` 或编译器高度优化的 `switch` 结构反而更高效。
- 设计模式是用来解决**特定重复出现的设计问题**的工具，而不是必须遵守的教条。如果为了使用模式而使用模式，往往会违背软件设计的核心原则：**KISS（Keep It Simple, Stupid）**。