---
layout: post
title: "Observer观察者模式"
subtitle: ""
date: 2025-10-09
author: "Can"
header-img: "img/croatia.jpg"
tags: ["Design-Pattern"]
---

# Observer观察者模式

## 定义

定义对象间的一种**一对多（变化）的依赖关系**，以便当一个对象（Subject）的状态发生改变的时候，所有依赖它的对象都能得到通知并自动更新。

## 结构

![observer](/img/in-post/observer.png)

## 例子

1. 抽象接口

   ```cpp
   // 抽象观察者 (Observer)
   class IObserver {
   public:
       virtual ~IObserver() {}
       // 纯虚函数：定义更新接口，接收主题的状态数据
       virtual void Update(const State& state_data) = 0; 
   };
   
   // 抽象主题 (Subject)
   class ISubject {
   public:
       virtual ~ISubject() {}
       // 注册/附加观察者
       void Attach(IObserver* observer) {
           observers_.push_back(observer); 
       }
       // 移除/分离观察者
       void Detach(IObserver* observer) {
           // ... (使用 std::remove 和 erase)
       }
   
   protected:
       // 通知所有观察者
       void Notify() {
           // 遍历容器，调用每个观察者的 Update 方法
           for (IObserver* obs : observers_) {
               obs->Update(this->GetState()); // 从主题获取状态
           }
       }
   
   private:
       std::vector<IObserver*> observers_;
       // 抽象主题可能需要定义一个获取状态的方法供 Notify 调用
       virtual State GetState() const = 0; 
   };
   ```

2. 具体实现

   ```cpp
   // 具体主题 (Concrete Subject)
   class WeatherStation : public ISubject {
   public:
       // 改变状态，并自动触发通知
       void SetTemperature(int new_temp) {
           temperature_ = new_temp;
           Notify(); // 调用 ISubject::Notify() 
       }
   
   private:
       int temperature_;
       // 实现抽象主题中获取状态的接口
       State GetState() const override {
           return State{"Temperature", temperature_}; // 假设 State 是一个结构体
       }
   };
   
   // 具体观察者
   class PhoneDisplay : public IObserver {
   public:
       // 构造函数中可以进行注册
       PhoneDisplay(ISubject* subject) {
           subject->Attach(this);
       }
   
       // 实现 Update 接口
       void Update(const State& state_data) override {
           if (state_data.key == "Temperature") {
               std::cout << "手机显示: 当前温度是 " << state_data.value << " 度" << std::endl;
           }
       }
   };
   ```

3. 使用示例

   ```cpp
   // 客户端 (main 函数内部)
   int main() {
       // 1. 创建主题 (在堆上分配)
       WeatherStation* station = new WeatherStation(); 
   
       // 2. 创建观察者并注册
       IObserver* phone_a = new PhoneDisplay(station);
       IObserver* tv_b = new TVDisplay(station); // 假设有另一个观察者
   
       // 3. 改变主题状态，观察者被通知
       station->SetTemperature(28); 
       // 输出: 手机显示: 当前温度是 28 度
       // 输出: 电视显示: ...
   
       // 4. 清理内存
       delete station;
       delete phone_a;
       delete tv_b;
   }
   ```

## 总结

- Observer模式通过面向对象的抽象使目标和观察者能够**独立变化**，从而实现二者之间的**松耦合**。
- 当目标发送通知时，无需指定具体观察者，**通知会自动传播**（可携带通知信息作为参数）。
- 观察者自主决定是否订阅通知，而**目标对象对此并无感知**。
- 该模式是**基于事件的UI框架中广泛使用的设计模式**，也是MVC架构的重要组成部分。