---
layout: post
title: "Facade门面模式"
subtitle: ""
date: 2025-12-05
author: "Can"
header-img: "img/background/rose.jpg"
tags: ["Design Pattern"]
---

## 问题

![facade-problem.png](/img/design-pattern/facade-problem.png)

## 动机

- 上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了**过多的耦合**，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。
- 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的**依赖相互解耦**？

## 定义

为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。  

## 结构

![facade.png](/img/design-pattern/facade.png)

## 示例

### 子系统类(Subsystem Classes)

这些是系统中的复杂组件，它们本身有多个方法。

```cpp
// --- 子系统 1: 投影仪 (Projector) ---
class Projector {
public:
    void on() {
        // 伪代码: 打开投影仪电源
        print("Projector is ON.");
    }

    void off() {
        // 伪代码: 关闭投影仪电源
        print("Projector is OFF.");
    }

    void wideScreenMode() {
        // 伪代码: 设置为宽屏模式
        print("Projector is set to wide screen mode.");
    }
};

// --- 子系统 2: 功放 (Amplifier) ---
class Amplifier {
public:
    void on() {
        // 伪代码: 打开功放电源
        print("Amplifier is ON.");
    }

    void off() {
        // 伪代码: 关闭功放电源
        print("Amplifier is OFF.");
    }

    void setDvd(DvdPlayer* dvd) {
        // 伪代码: 设置输入源为 DVD
        print("Amplifier input set to DVD.");
    }

    void setVolume(int volume) {
        // 伪代码: 设置音量
        print("Amplifier volume set to " + volume);
    }
};

// --- 子系统 3: DVD 播放器 (DvdPlayer) ---
class DvdPlayer {
public:
    void on() {
        // 伪代码: 打开 DVD 播放器
        print("DvdPlayer is ON.");
    }

    void off() {
        // 伪代码: 关闭 DVD 播放器
        print("DvdPlayer is OFF.");
    }

    void play(string movie) {
        // 伪代码: 播放电影
        print("DvdPlayer is playing '" + movie + "'.");
    }

    void stop() {
        // 伪代码: 停止播放
        print("DvdPlayer stopped.");
    }
};
```

### 门面类 (Facade Class)

`HomeTheaterFacade` 封装了对所有子系统类的复杂调用序列。

```cpp
class HomeTheaterFacade {
private:
    Projector* projector;
    Amplifier* amp;
    DvdPlayer* dvd;

public:
    // 构造函数，传入子系统实例
    HomeTheaterFacade(Projector* proj, Amplifier* amplifier, DvdPlayer* player) {
        projector = proj;
        amp = amplifier;
        dvd = player;
    }

    // 门面方法 1: 观看电影 (一键操作)
    void watchMovie(string movie) {
        print("\nGet ready to watch a movie...");
        
        // 复杂的子系统调用序列被封装
        projector->on();
        projector->wideScreenMode();
        
        amp->on();
        amp->setDvd(dvd);
        amp->setVolume(10);
        
        dvd->on();
        dvd->play(movie);
        
        print("\nMovie setup complete!");
    }

    // 门面方法 2: 结束电影 (一键操作)
    void endMovie() {
        print("\nShutting down the home theater...");

        // 关闭所有组件
        dvd->stop();
        dvd->off();
        
        amp->off();
        projector->off();

        print("\nHome theater is off.");
    }
};
```

### 客户端代码 (Client Code)

客户端现在只需要与 `HomeTheaterFacade` 交互，无需知道子系统的复杂细节。

```cpp
int main() {
    // 实例化所有子系统
    Projector projector;
    Amplifier amplifier;
    DvdPlayer dvd;

    // 实例化门面，并将子系统传递给它
    HomeTheaterFacade homeTheater(&projector, &amplifier, &dvd);

    // 客户端只需要调用两个简单的方法！

    // 动作 1: 观看电影
    homeTheater.watchMovie("The Matrix");

    // 动作 2: 结束电影
    homeTheater.endMovie();

    return 0;
}

// 伪代码输出 (Client Code 运行结果):
// 
// Get ready to watch a movie...
// Projector is ON.
// Projector is set to wide screen mode.
// Amplifier is ON.
// Amplifier input set to DVD.
// Amplifier volume set to 10
// DvdPlayer is ON.
// DvdPlayer is playing 'The Matrix'.
// 
// Movie setup complete!
// 
// Shutting down the home theater...
// DvdPlayer stopped.
// DvdPlayer is OFF.
// Amplifier is OFF.
// Projector is OFF.
// 
// Home theater is off.
```

## 优点

- **简化调用**：客户端代码与子系统的**交互变得非常简单**，只需要调用门面类的一个或少数几个方法。
- **解耦**：客户端与子系统完全**解耦**。如果子系统中的接口发生变化，只要门面类的接口保持不变，客户端代码就不需要修改。
- **分层结构**：有助于将软件分成不同的层，提高系统的**可维护性**。

## 总结

- 从客户程序的角度来说，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果——**内部子系统的任何变化都不会影响Facade接口的变化**。
- Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种**架构设计模式**。
- Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中**组件的内部应该是“相互耦合关系比较大的一系列组件”**，而不是一个简单的功能集合。
