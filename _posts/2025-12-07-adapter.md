---
layout: post
title: "Adapter适配器模式"
subtitle: ""
date: 2025-12-07
author: "Can"
header-img: "img/background/crane.jpg"
tags: ["Design Pattern"]
---

## 动机

- 在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。
- 如何应对这种“迁移的变化”？如何既能立于哦那个现有对象的良好实现，同时又能满足新的应用环境所要求的接口？

## 定义

将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

## 结构

![adapter](/img/design-pattern/adapter.png)

## 示例

### 目标接口 (Target)

这是客户端期望使用的现代接口。

```cpp
// 现代接口：HDMI 输出
class HDMIOutput {
public:
    virtual ~HDMIOutput() = default;
    virtual void playHDMI() = 0; // 客户端期待的方法
};
```

### 待适配的类 (Adaptee)

这是一个已经存在、功能完备，但接口不匹配的旧系统或第三方库。

```cpp
// 旧系统：VGA 投影仪
class OldVGAProjector {
public:
    void projectWithVGA() {
        std::cout << ">>> 旧投影仪正在通过 VGA 信号播放画面..." << std::endl;
    }
};
```

### 适配器类 (Adapter)

适配器通过继承目标接口并持有待适配对象的引用（组合），来完成接口转换。

```cpp
class HDMItoVGAAdapter : public HDMIOutput {
private:
    OldVGAProjector* oldProjector; // 持有旧系统指针

public:
    HDMItoVGAAdapter(OldVGAProjector* projector) : oldProjector(projector) {}

    // 实现现代接口的方法
    void playHDMI() override {
        std::cout << "[适配器] 接收 HDMI 信号，正在转换为 VGA..." << std::endl;
        // 核心：调用旧系统的功能
        oldProjector->projectWithVGA();
    }
};
```

### 客户端调用 (Client)

```cpp
int main() {
    // 1. 我们有一台旧投影仪
    OldVGAProjector oldDevice;

    // 2. 笔记本电脑期望使用 HDMI 接口
    // 但我们可以通过适配器把它伪装成 HDMI 接口
    HDMIOutput* adapter = new HDMItoVGAAdapter(&oldDevice);

    // 3. 电脑无感地调用 HDMI 接口播放内容
    adapter->playHDMI();

    delete adapter;
    return 0;
}
```

### 核心逻辑

转换器角色：适配器并不实现真正的投影功能，它只是一个“翻译官”。

兼容性：在不修改旧类 `OldVGAProjector` 代码的前提下（符合**开闭原则**），让它能够支持新接口。

解耦：客户端代码只知道 `HDMIOutput` 接口，不知道底层其实是一个旧的 VGA 设备在工作。

## 总结

- Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在**遗留代码复用**、**类库迁移**等方面非常有用。
- GoF 23 定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用**对象组合**的方式，更符合**松耦合**精神。
- Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法的参数，来达到适配的目的。
