---
layout: post
title: "Proxy代理模式"
subtitle: ""
date: 2025-12-07
author: "Can"
header-img: "img/background/city.jpg"
tags: ["Design Pattern"]
---

## 动机

- 在面向对象系统中，有些对象由于某种原因（比如**对象创建的开销很大**，或者**某些操作需要安全控制**，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。
- 如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。

## 定义

为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。

## 结构

![proxy.png](/img/design-pattern/proxy.png)

## 示例

### 抽象接口 (Subject)

定义真实对象和代理对象的公共接口。

```cpp
// 抽象接口：文档系统
class Document {
public:
    virtual ~Document() = default;
    virtual void download(const std::string& user) = 0;
};
```

### 真实对象 (Real Subject)

执行核心业务逻辑：实际的文件下载。

```cpp
class RealDocument : public Document {
private:
    std::string fileName;
public:
    RealDocument(std::string name) : fileName(name) {}

    void download(const std::string& user) override {
        std::cout << ">>> 正在执行磁盘 IO，为 [" << user << "] 下载文件: " << fileName << std::endl;
    }
};
```

### 代理对象 (Proxy)

包含权限校验、日志记录和延迟加载逻辑。

```cpp
class ProxyDocument : public Document {
private:
    std::unique_ptr<RealDocument> realDocument; // 组合真实对象
    std::string fileName;

    // 模拟权限验证逻辑
    bool checkAccess(const std::string& user) {
        return user == "admin"; // 仅限管理员
    }

    void logOperation(const std::string& user, const std::string& action) {
        std::cout << "[审计日志] 用户: " << user << " 执行动作: " << action << std::endl;
    }

public:
    ProxyDocument(std::string name) : fileName(name), realDocument(nullptr) {}

    void download(const std::string& user) override {
        // 1. 日志记录
        logOperation(user, "尝试下载 " + fileName);

        // 2. 权限校验
        if (checkAccess(user)) {
            // 3. 延迟加载 (Lazy Initialization)
            if (!realDocument) {
                realDocument = std::make_unique<RealDocument>(fileName);
            }
            realDocument->download(user);
            logOperation(user, "下载成功");
        } else {
            std::cout << "[拒绝访问] 用户权限不足，操作已拦截！" << std::endl;
        }
    }
};
```

### 客户端 (Client)

```cpp
int main() {
    // 客户端通过接口指向代理
    std::unique_ptr<Document> docProxy = std::make_unique<ProxyDocument>("2025_财报.pdf");

    // 场景 A：普通用户尝试访问
    std::cout << "--- 场景 1: 普通用户 ---" << std::endl;
    docProxy->download("guest");

    std::cout << "\n--- 场景 2: 管理员用户 ---" << std::endl;
    // 场景 B：管理员访问
    docProxy->download("admin");

    return 0;
}
```

### 关键职责

- **权限校验**：真实对象 `RealDocument` 的逻辑被封装，只有通过代理的校验才能进入。
- **日志记录**：在不修改原始下载逻辑的情况下，增加了审计功能。
- **延迟加载**：真实对象可能很大（如大文件模型），代理确保只有在权限通过且真正需要时才创建对象。

## 总结

- **“增加一层间接层”**是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。
- 具体proxy设计模式的实现方法、**实现粒度都相差很大**，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。
- **Proxy并不一定要求保持接口完整的一致性**，只要能够实现间接控制，有时候损及一些透明性是可以接受的。
