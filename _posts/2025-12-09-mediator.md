---
layout: post
title: "Mediator中介者模式"
subtitle: ""
date: 2025-12-09
author: "Can"
header-img: "img/background/leaf.jpg"
tags: ["Design Pattern"]
---

## Motivation

- 在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。
- 在这种情况下，我们可以使用一个“中介对象”来管理对象间的间接关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。

## Definition

用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（**编译时依赖-> 运行时依赖**），从而使其**耦合松散**（管理变化），而且可以独立地改变它们之间的交互。

## Structure

![mediator](/img/design-pattern/mediator.png)

## Example

### Mediator Interface

```cpp
class Device;
class Mediator {
public:
    virtual void notify(Device* sender, std::string event) = 0;
};
```

### Base Colleague

```cpp
class Device {
protected:
    Mediator* mediator; // 持有中介者的引用
public:
    Device(Mediator* m) : mediator(m) {}
};
```

### Concrete Colleague

#### Smart Light

```cpp
class SmartLight : public Device {
public:
    using Device::Device;
    void turnOn() { std::cout << "[SmartLight] 已开启，亮度 100%.\n"; }
    void turnOff() { std::cout << "[SmartLight] 已关闭.\n"; }
};
```

#### Smart Air Conditioner

```cpp
class AirConditioner : public Device {
public:
    using Device::Device;
    void startCooling() { std::cout << "[AirConditioner] 开始制冷，设定 26 度.\n"; }
};
```

#### Smart Motion Sensor

```cpp
class MotionSensor : public Device {
public:
    using Device::Device;
    void detectMotion() {
        std::cout << "[MotionSensor] 检测到有人经过...\n";
        mediator->notify(this, "motion_detected"); // 仅通知中介者，不联系灯和空调
    }
};
```

### Smart Gateway(Concrete Mediator)

```cpp
class SmartGateway : public Mediator {
private:
    SmartLight* light;
    AirConditioner* ac;

public:
    void setLight(SmartLight* l) { light = l; }
    void setAC(AirConditioner* a) { ac = a; }

    // 核心联动逻辑：中介者决定谁该干什么
    void notify(Device* sender, std::string event) override {
        if (event == "motion_detected") {
            std::cout << "[Gateway] 收到传感器信号，正在执行自动化规则...\n";
            if (light) light->turnOn();
            if (ac) ac->startCooling();
        }
    }
};
```

### Client Code

```cpp
int main() {
    // 创建中介者
    SmartGateway* gateway = new SmartGateway();

    // 创建设备并连接到中介者
    SmartLight* light = new SmartLight(gateway);
    AirConditioner* ac = new AirConditioner(gateway);
    MotionSensor* sensor = new MotionSensor(gateway);

    // 在网关中注册设备
    gateway->setLight(light);
    gateway->setAC(ac);

    // 触发事件
    sensor->detectMotion(); 

    return 0;
}
```

## Conclusion

- 将多个对象间复杂的关联对象解耦，Modiator模式将多个对象间的控制逻辑进行集中管理，**变“多个对象互动关联”为“多个对象和一个中介者关联”**，简化了系统的维护，抵御了可能的变化。
- 随着控制逻辑的复杂化，Midiator具体对象的实现可能相当复杂。这时候可以对Midiator对象进行分解处理。
- Facade模式是解耦系统间（单向）的对象关联关系；Mediator模式是解耦系统内各个对象之间（双向）的关联关系。
