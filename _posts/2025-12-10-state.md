---
layout: post
title: "State状态模式"
subtitle: ""
date: 2025-12-10
author: "Can"
header-img: "img/background/bridge-1.jpg"
tags: ["Design Pattern"]
---

## Motivation

在软件构建过程中，某些对象的状态如果改变，其行为也会随之发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。如何在运行时根据对象的状态来透明地更改对象的行为？而不是为对象操作和状态转化之间引入紧耦合。

## Definition

允许一个对象在其内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为。

## Structure

![state](/img/design-pattern/state.png)

## Example

### Abstract State

定义所有具体状态类需要实现的接口。

```cpp
// 抽象状态类：MediaPlayerState
// 定义了在特定状态下播放器可以执行的操作
class MediaPlayerState {
public:
    // 析构函数
    virtual ~MediaPlayerState() = default;

    // 处理“播放/暂停”按钮点击
    virtual void handlePlayPause(MediaPlayer* player) = 0;

    // 处理“停止”按钮点击
    virtual void handleStop(MediaPlayer* player) = 0;

    // 打印当前状态名称 (可选，用于调试和展示)
    virtual void printStatus() const = 0;
};
```

### Concrete State

实现抽象状态接口，为每个状态提供特定的行为。

```cpp
// 具体状态 1: StoppedState (停止状态)
class StoppedState : public MediaPlayerState {
public:
    void printStatus() const override {
        std::cout << "当前状态：停止" << std::endl;
    }

    void handlePlayPause(MediaPlayer* player) override {
        std::cout << "==> 正在启动播放..." << std::endl;
        // 行为改变：从停止状态切换到播放状态
        player->changeState(new PlayingState());
    }

    void handleStop(MediaPlayer* player) override {
        std::cout << "已处于停止状态，无需操作。" << std::endl;
    }
};

// 具体状态 2: PlayingState (播放状态)
class PlayingState : public MediaPlayerState {
public:
    void printStatus() const override {
        std::cout << "当前状态：正在播放" << std::endl;
    }

    void handlePlayPause(MediaPlayer* player) override {
        std::cout << "==> 正在暂停播放..." << std::endl;
        // 行为改变：从播放状态切换到暂停状态
        player->changeState(new PausedState());
    }

    void handleStop(MediaPlayer* player) override {
        std::cout << "==> 正在停止播放..." << std::endl;
        // 行为改变：从播放状态切换到停止状态
        player->changeState(new StoppedState());
    }
};

// 具体状态 3: PausedState (暂停状态)
class PausedState : public MediaPlayerState {
public:
    void printStatus() const override {
        std::cout << "当前状态：暂停" << std::endl;
    }

    void handlePlayPause(MediaPlayer* player) override {
        std::cout << "==> 正在恢复播放..." << std::endl;
        // 行为改变：从暂停状态切换到播放状态
        player->changeState(new PlayingState());
    }

    void handleStop(MediaPlayer* player) override {
        std::cout << "==> 正在停止播放..." << std::endl;
        // 行为改变：从暂停状态切换到停止状态
        player->changeState(new StoppedState());
    }
};
```

### Context

环境（Context）是包含状态对象的类，它将所有的状态特定的行为委托给当前的状态对象。

```cpp
// 环境类：MediaPlayer
// 包含一个指向当前状态对象的指针
class MediaPlayer {
private:
    MediaPlayerState* currentState;

public:
    // 构造函数：初始化时处于停止状态
    MediaPlayer() {
        // 初始状态
        currentState = new StoppedState();
        std::cout << "媒体播放器启动，初始状态为：停止" << std::endl;
    }

    ~MediaPlayer() {
        delete currentState;
    }

    // 状态切换方法 (供具体状态调用)
    void changeState(MediaPlayerState* newState) {
        // 安全释放旧状态
        delete currentState;
        currentState = newState;
        currentState->printStatus();
    }

    // 客户端调用的方法，委托给当前状态对象
    void pressPlayPause() {
        std::cout << "\n[操作] 按下播放/暂停键" << std::endl;
        currentState->handlePlayPause(this);
    }

    void pressStop() {
        std::cout << "\n[操作] 按下停止键" << std::endl;
        currentState->handleStop(this);
    }
    
    // 获取当前状态 (可选)
    void showStatus() const {
        std::cout << "\n[查询] ";
        currentState->printStatus();
    }
};

```

### Client

```cpp
// 客户端代码 (main 函数)
void main() {
    // 1. 创建播放器，默认为停止状态
    MediaPlayer player; // 媒体播放器启动，初始状态为：停止

    // --- 第一次操作：从停止 -> 播放 ---
    player.pressPlayPause();
    // [操作] 按下播放/暂停键
    // ==> 正在启动播放...
    // 当前状态：正在播放

    // --- 第二次操作：从播放 -> 暂停 ---
    player.pressPlayPause();
    // [操作] 按下播放/暂停键
    // ==> 正在暂停播放...
    // 当前状态：暂停

    // --- 第三次操作：从暂停 -> 播放 ---
    player.pressPlayPause();
    // [操作] 按下播放/暂停键
    // ==> 正在恢复播放...
    // 当前状态：正在播放

    // --- 第四次操作：从播放 -> 停止 ---
    player.pressStop();
    // [操作] 按下停止键
    // ==> 正在停止播放...
    // 当前状态：停止

    // --- 第五次操作：在停止状态下再次按停止 ---
    player.pressStop();
    // [操作] 按下停止键
    // 已处于停止状态，无需操作。
    // 当前状态：停止
}
```

### Advantage

- 消除大量的 `if/else` 或 `switch` 语句: 状态模式将状态相关的行为逻辑分离到独立的类中。
- **开放/封闭原则 (OCP)**: 增加新的状态时，只需添加新的状态类，而无需修改环境类 (MediaPlayer) 或现有的状态类。
- **单一职责原则 (SRP)**: 每个状态类只负责管理和实现与该状态相关的行为，而不是将所有状态逻辑都放在环境类中。

## Conclusion

- State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了**具体操作与状态转换之间的解耦**。
- 为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为**状态转换是原子性的——即要么彻底转换过来，要么不转换**。
- 如果State对象没有实例变量，那么各上下文可以**共享同一个State对象(Singleton)**，从而节省对象开销。
