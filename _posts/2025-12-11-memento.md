---
layout: post
title: "Memento备忘录模式"
subtitle: ""
date: 2025-12-11
author: "Can"
header-img: "img/background/dog.jpg"
tags: ["Design Pattern"]
---

## Motivation

- 在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。
- 如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。

## Definition

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

## Structure

![memento](/img/design-pattern/memento.png)

## Example

### Memento（备忘录）类

```cpp
// 存储 Originator 的内部状态
class Memento {
public:
    // 构造函数，接收 Originator 的状态
    Memento(const string& state) : state_(state) {}

    // 仅允许 Originator 访问其内部状态
    // 通常通过友元类（friend class）或将 Originator 放在同一命名空间实现
    // 在这个伪代码中，我们使用公共方法，但实际设计中应严格控制访问权限
    string GetState() const {
        return state_;
    }

private:
    string state_; // 存储 Originator 状态
};
```

### Originator（发起人）类

```cpp
class Originator {
public:
    // 设置 Originator 的当前状态
    void SetState(const string& state) {
        state_ = state;
        cout << "Originator: 设置状态为 - " << state_ << endl;
    }

    // 获取 Originator 的当前状态
    string GetState() const {
        return state_;
    }

    // 创建一个备忘录（Memento），记录当前状态
    Memento CreateMemento() const {
        cout << "Originator: 创建备忘录（Memento）." << endl;
        // 注意：这里将状态字符串传入 Memento 构造函数
        return Memento(state_);
    }

    // 使用备忘录（Memento）恢复到之前的状态
    void RestoreMemento(const Memento& memento) {
        state_ = memento.GetState();
        cout << "Originator: 从备忘录中恢复状态为 - " << state_ << endl;
    }

private:
    string state_; // Originator 的内部状态
};
```

### Caretaker（负责人）类

```cpp
class Caretaker {
public:
    // 保存 Memento
    void Save(const Memento& memento) {
        history_.push_back(memento);
        cout << "Caretaker: 保存了一个备忘录。" << endl;
    }

    // 获取并移除最新的 Memento
    Memento Undo() {
        if (history_.empty()) {
            throw runtime_error("没有可撤销的备忘录");
        }
        Memento memento = history_.back();
        history_.pop_back();
        cout << "Caretaker: 恢复并移除了最新的备忘录。" << endl;
        return memento;
    }

private:
    // 用于存储多个 Memento 的容器
    vector<Memento> history_;
};
```

### Client（客户端）类

```cpp
void ClientCode() {
    Originator originator; // 创建发起人
    Caretaker caretaker;   // 创建负责人

    // 1. 设置初始状态并保存
    originator.SetState("State_A");
    caretaker.Save(originator.CreateMemento()); // 状态 A 存入历史

    // 2. 更改状态并保存
    originator.SetState("State_B");
    caretaker.Save(originator.CreateMemento()); // 状态 B 存入历史

    // 3. 再次更改状态（不保存）
    originator.SetState("State_C");
    cout << "Originator 当前状态: " << originator.GetState() << endl;

    // 4. 撤销（Undo）到上一个状态 (State_B)
    cout << "\n--- 执行撤销操作 ---" << endl;
    Memento previousState = caretaker.Undo();
    originator.RestoreMemento(previousState);
    cout << "Originator 恢复后的状态: " << originator.GetState() << endl; // 状态 B

    // 5. 再次撤销（Undo）到更早的状态 (State_A)
    cout << "\n--- 执行再次撤销操作 ---" << endl;
    Memento initialMemento = caretaker.Undo();
    originator.RestoreMemento(initialMemento);
    cout << "Originator 恢复后的状态: " << originator.GetState() << endl; // 状态 A
}

// 假设的 main 函数入口
// int main() {
//     ClientCode();
//     return 0;
// }
```

### 关键点解释

- **封装性保护：**Memento 类的内部状态 (state_) 通常应该是私有的，只有 Originator 应该有权访问 Memento 的内部状态，以便进行保存和恢复。Caretaker 只知道 Memento 是一个可以保存和传递的对象，但无法直接访问或修改其内部状态 (state_)，从而保护了 Originator 的封装性。
- **状态保存与恢复：**Originator 可以创建 Memento 来保存其当前状态，也可以通过 Memento 恢复到之前的状态。Caretaker 负责管理多个 Memento，通常以栈（Stack）或队列（Queue）的形式存储。
- **状态管理：**Caretaker 负责管理多个 Memento，通常以栈（Stack）或队列（Queue）的形式存储。栈（Stack）适用于需要撤销操作的场景，而队列（Queue）则适用于需要按顺序恢复状态的场景。
- **负责人职责：**Caretaker 负责管理备忘录的生命周期（存储、检索、销毁），常用于实现“撤销/重做”功能。它将备忘录存储在一个历史列表（如 vector<Memento>）中。

## Conclusion

- 备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器的状态。
- Memento模式的核心是**信息隐藏**，即Originator需要向外隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。
- 由于现在语言运行时（如C#、Java等）都具有相当的**序列化支持**，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。
