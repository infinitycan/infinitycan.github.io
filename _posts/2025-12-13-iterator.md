---
layout: post
title: "Iterator迭代器模式"
subtitle: ""
date: 2025-12-13
author: "Can"
header-img: "img/background/sunset.jpg"
tags: ["Design Pattern"]
---

## Motivation

- 在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。
- 使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。

## Definition

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。

## Structure

![iterator](/img/design-pattern/iterator.png)

## Example

### 迭代器接口 (Iterator Interface)

```cpp
// 迭代器接口
class Iterator {
public:
    virtual ~Iterator() {}
    // 返回当前元素
    virtual Book* currentItem() const = 0;
    // 移动到下一个元素
    virtual void next() = 0;
    // 检查是否已经遍历到末尾
    virtual bool isDone() const = 0;
    // 移动到起始元素（可选操作）
    virtual void first() = 0;
};
```

### 集合接口 (Aggregate Interface)

```cpp
// 集合接口
class Aggregate {
public:
    virtual ~Aggregate() {}
    // 创建一个迭代器对象
    virtual Iterator* createIterator() = 0;
    // 获取集合大小
    virtual int count() const = 0;
    // 获取指定位置的元素
    virtual Book* getElement(int index) const = 0;
};
```

### 具体集合 (Concrete Aggregate)

```cpp
// 辅助类：书籍
class Book {
private:
    std::string title;
public:
    Book(const std::string& t) : title(t) {}
    std::string getTitle() const { return title; }
};

// 具体集合：书籍列表
class BookList : public Aggregate {
private:
    std::vector<Book*> books; // 内部使用 std::vector 存储元素
public:
    BookList() {}
    ~BookList() { /* 释放 books 中的 Book 对象 */ }

    void add(Book* book) {
        books.push_back(book);
    }

    // 实现 Aggregate 接口
    Iterator* createIterator() override; // 将在 Concrete Iterator 中定义实现

    int count() const override {
        return books.size();
    }

    Book* getElement(int index) const override {
        if (index >= 0 && index < books.size()) {
            return books[index];
        }
        return nullptr; // 索引越界
    }
};
```

### 具体迭代器 (Concrete Iterator)

```cpp
// 具体迭代器：BookList 的迭代器
class BookListIterator : public Iterator {
private:
    const BookList* aggregate; // 保持对集合的引用
    int currentIndex;          // 当前位置索引

public:
    BookListIterator(const BookList* list) : aggregate(list), currentIndex(0) {}
    ~BookListIterator() override {}

    void first() override {
        currentIndex = 0;
    }

    Book* currentItem() const override {
        if (!isDone()) {
            return aggregate->getElement(currentIndex);
        }
        return nullptr;
    }

    void next() override {
        if (!isDone()) {
            currentIndex++;
        }
    }

    bool isDone() const override {
        return currentIndex >= aggregate->count();
    }
};

// 完成 Concrete Aggregate 的 createIterator() 实现
Iterator* BookList::createIterator() {
    return new BookListIterator(this);
}
```

### 客户端代码（Client）

```cpp
// 客户端使用
void clientCode() {
    // 1. 创建具体集合
    BookList* myBooks = new BookList();
    myBooks->add(new Book("《设计模式》"));
    myBooks->add(new Book("《Effective C++》"));
    myBooks->add(new Book("《深入理解计算机系统》"));

    // 2. 从集合中获取迭代器
    Iterator* iterator = myBooks->createIterator();

    std::cout << "--- 遍历书籍列表 ---" << std::endl;

    // 3. 使用迭代器进行遍历
    for (iterator->first(); !iterator->isDone(); iterator->next()) {
        Book* book = iterator->currentItem();
        std::cout << "书名: " << book->getTitle() << std::endl;
    }

    // 4. 清理
    delete iterator;
    delete myBooks; // 释放集合和其中包含的 Book 对象
}

// 运行客户端代码
// clientCode();

/* 预期输出:
--- 遍历书籍列表 ---
书名: 《设计模式》
书名: 《Effective C++》
书名: 《深入理解计算机系统》
*/
```

## Conclusion

- 迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。
- 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
- 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。
