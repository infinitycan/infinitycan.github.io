---
layout: post
title: "Command命令模式"
subtitle: ""
date: 2025-12-15
author: "Can"
header-img: "img/background/popup.jpg"
tags: ["Design Pattern"]
---

## Motivation

- 在软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合——比如需要对行为进行“记录、撤销/重做（undo/redo、事务）”等处理，这些无法抵御变化的紧耦合是不适合的。
- 在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

## Defination

将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

## Structure

![command](/img/design-pattern/command.png)

## Example

模拟一个简单的遥控器，它可以控制灯光（Light）。

### Receiver (接收者) - Light (灯光)

```cpp

// Receiver（接收者）：执行实际操作的类
class Light {
public:
    void on() {
        // 实际操作：打开灯光
        print("Light is ON.");
    }

    void off() {
        // 实际操作：关闭灯光
        print("Light is OFF.");
    }
};
```

### Command (命令接口)

```cpp
// Command（命令接口）：声明执行操作的接口
class Command {
public:
    virtual ~Command() = default;
    // 抽象方法：执行命令
    virtual void execute() = 0;
};
```

### ConcreteCommand (具体命令)

```cpp
// ConcreteCommand（具体命令）：打开灯光的命令
class LightOnCommand : public Command {
private:
    Light* light; // 绑定到具体的接收者

public:
    // 构造函数：需要知道对哪个接收者进行操作
    LightOnCommand(Light* l) : light(l) {}

    void execute() override {
        // 调用接收者的方法来执行实际的请求
        light->on();
    }
};

// ConcreteCommand（具体命令）：关闭灯光的命令
class LightOffCommand : public Command {
private:
    Light* light;

public:
    LightOffCommand(Light* l) : light(l) {}

    void execute() override {
        light->off();
    }
};
```

### Invoker (调用者) - RemoteControl (遥控器)

```cpp
// Invoker（调用者/请求者）：遥控器
class RemoteControl {
private:
    Command* commandSlot; // 持有命令对象的槽位

public:
    // 设置命令
    void setCommand(Command* command) {
        commandSlot = command;
    }

    // 按下按钮：执行命令
    void pressButton() {
        if (commandSlot) {
            print("遥控器：按下按钮 -> 执行命令...");
            commandSlot->execute();
        } else {
            print("遥控器：未设置命令。");
        }
    }
};
```

### Client (客户端) - 应用程序

```cpp
// Client（客户端）：应用程序主逻辑
void client_code() {
    // 1. 创建接收者
    Light* myLight = new Light();

    // 2. 创建具体命令，并将接收者绑定到命令上
    Command* lightOn = new LightOnCommand(myLight);
    Command* lightOff = new LightOffCommand(myLight);

    // 3. 创建调用者 (遥控器)
    RemoteControl* remote = new RemoteControl();

    // --- 使用遥控器打开灯光 ---
    print("\n--- 准备打开灯光 ---");
    remote->setCommand(lightOn);
    remote->pressButton();

    // --- 使用遥控器关闭灯光 ---
    print("\n--- 准备关闭灯光 ---");
    remote->setCommand(lightOff);
    remote->pressButton();

    // --- 清理 ---
    delete myLight;
    delete lightOn;
    delete lightOff;
    delete remote;
}

// 假设的 main 函数
// int main() {
//     client_code();
//     return 0;
// }
```

### Advantage

- **解耦：**调用者（RemoteControl）与接收者（Light）完全解耦，它们之间只通过抽象的 Command 接口进行通信。
- **扩展性：**可以很容易地添加新的命令（如添加新的操作，如打开电视、关闭电视等），而无需修改现有的代码。
- **可撤销/重做：**由于每个命令都是一个对象，因此可以很容易地实现撤销（undo）和重做（redo）操作。

## Conclusion

- Command模式的根本目的在于**将“行为请求者”与“行为实现者”解耦**，在面向对象语言中，常见的实现手段是“**将行为抽象为对象**”。
- 实现Command接口的具体命令对象ConcreteCommand**有时候根据需要可能会保存一些额外的状态信息**。通过使用Composite模式，可以将多个“命令”封装为一个“符合命令”MacroCommand。
- Command模式与C++中的函数对象有些类似。但二者定义行为接口的规范有所区别：**Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，但存在性能损失。C++函数对象以函数签名来定义行为接口规范，更灵活，性能也更高。**
