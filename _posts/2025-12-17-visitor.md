---
layout: post
title: "Visitor访问器模式"
subtitle: ""
date: 2025-12-17
author: "Can"
header-img: "img/background/forest.jpg"
tags: ["Design Pattern"]
---

## Motivation

- 在软件构建过程中，由于需求的改变，某些类层次结构常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。
- 如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？

## Defination

表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。

## Structure

![visitor](/img/design-pattern/visitor.png)

## Example

假设我们正在开发一个绘图软件，里面有“圆形”和“矩形”，我们想在不修改形状类代码的前提下，增加“导出 JSON”和“计算面积”的功能。

```cpp
// 1. 前向声明，让 Element 知道 Visitor 的存在
class Circle;
class Rectangle;
```

### Visitor

```cpp
// 2. 访问者接口：定义对每种具体元素的访问操作
class Visitor {
public:
    virtual void visitCircle(Circle* c) = 0;
    virtual void visitRectangle(Rectangle* r) = 0;
    virtual ~Visitor() = default;
};
```

### Element

```cpp
// 3. 元素接口：声明接受访问者的方法
class Shape {
public:
    // 关键方法：Accept
    virtual void accept(Visitor* v) = 0;
    virtual ~Shape() = default;
};
```

### Concrete Element

```cpp
// 4. 具体元素：实现 accept 方法
class Circle : public Shape {
public:
    void accept(Visitor* v) override {
        // 这是模式的核心：双分派（Double Dispatch）
        // 告诉访问者：“我是圆形，请调用访问圆形的逻辑”
        v->visitCircle(this);
    }
    double getRadius() { return 5.0; }
};

class Rectangle : public Shape {
public:
    void accept(Visitor* v) override {
        v->visitRectangle(this);
    }
    double getWidth() { return 10.0; }
    double getHeight() { return 2.0; }
};
```

### Concrete Visitor

```cpp
// 5. 具体访问者 A：实现导出 JSON 的功能
class JsonExportVisitor : public Visitor {
public:
    void visitCircle(Circle* c) override {
        cout << "{ \"type\": \"circle\", \"radius\": " << c->getRadius() << " }" << endl;
    }
    void visitRectangle(Rectangle* r) override {
        cout << "{ \"type\": \"rect\", \"w\": " << r->getWidth() << " }" << endl;
    }
};

// 6. 具体访问者 B：实现计算面积的功能
class AreaVisitor : public Visitor {
public:
    void visitCircle(Circle* c) override {
        double area = 3.14 * c->getRadius() * c->getRadius();
        cout << "Circle Area: " << area << endl;
    }
    void visitRectangle(Rectangle* r) override {
        double area = r->getWidth() * r->getHeight();
        cout << "Rectangle Area: " << area << endl;
    }
};
```

### Client

```cpp
// --- 客户端使用 ---
int main() {
    // 准备对象结构（形状列表）
    vector<Shape*> shapes = { new Circle(), new Rectangle() };

    // 创建具体的算法（访问者）
    JsonExportVisitor jsonVisitor;
    AreaVisitor areaVisitor;

    // 应用算法 1：导出 JSON
    for (auto s : shapes) {
        s->accept(&jsonVisitor);
    }

    // 应用算法 2：计算面积
    for (auto s : shapes) {
        s->accept(&areaVisitor);
    }

    return 0;
}
```

### Advantage

- **符合“开闭原则”：**对对象结构的修改是封闭的，而对操作的修改是开放的。
- **单一职责原则：**将相关的行为集中到访问者中，而不是让形状类充斥着各种无关的业务逻辑（如导出、渲染、统计）。
- **双分派机制：**accept 方法能够根据元素类型和访问者类型共同决定执行哪段逻辑。

## Conclusion

- Visitor模式通过所谓双重分发（double dispatch）来实现在不更改（不添加新的操作-编译时）Element类层次结构的前提下，**在运行时透明地为类层次结构上的各个类动态添加新的操作**（支持变化）。
- 所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。
- Visitor模式的**最大缺点在于扩展类层次结构（增添新的Element子类），会导致Visitor类的改变**。因此Visitor模式适用于“Element类层次结构稳定，而其中的操作却经常面临频繁改动”。
